# 核心架构设计文档

## 架构概览

本项目采用分层架构，将缓存管理、状态管理和事件系统集成到统一的数据流架构中。这种设计可以确保数据在不同层之间高效流动，减少重复代码，并提供更好的错误处理和离线功能。

```
┌─────────────────┐     ┌──────────────────┐     ┌───────────────┐
│  用户界面层 (UI) │────→│  状态管理 (State)  │←───→│ API/服务层     │
└────────┬────────┘     └──────────┬───────┘     └─────┬─────────┘
         │                         │                    │
         │                         ↓                    │
         │              ┌────────────────────┐          │
         └─────────────→│ 事件总线 (EventBus) │←─────────┘
                        └────────────────────┘
                                   ↕
                        ┌────────────────────┐
                        │ 缓存系统 (Cache)    │
                        └────────────────────┘
```

## 主要组件

### 统一缓存管理（CacheManager）

缓存系统是一个多层次的存储系统，支持：

- **本地持久缓存**：使用localStorage存储，重启后保留
- **会话缓存**：使用sessionStorage存储，页面刷新后清除
- **内存缓存**：仅在当前页面生命周期内有效

特性包括：
- 自动过期机制
- 基于标签的缓存查询和清理
- 缓存大小限制和LRU淘汰策略
- 缓存事件通知

### 集成层（Integration）

集成层将各个核心系统连接起来，提供：

- **状态-缓存同步**：状态变化自动同步到缓存
- **API-缓存集成**：API响应自动缓存并在离线时使用
- **网络状态监听**：监听网络状态并触发相应事件
- **全局错误捕获**：集中处理和记录错误
- **数据自动刷新**：定期刷新重要数据

### 初始化流程（Init）

应用初始化过程有明确的阶段划分：
1. 系统初始化
2. 缓存系统初始化
3. 主题初始化
4. 国际化初始化
5. 状态管理初始化
6. API系统初始化
7. 集成层初始化
8. 认证初始化

每个阶段都有进度报告和错误处理机制。

### 应用提供器（AppProvider）

作为React应用的顶层组件，负责：
- 协调所有系统的初始化
- 提供全局错误边界
- 显示初始化进度和错误状态
- 管理应用资源的清理

## 数据流

### 状态 → 缓存同步流程

```
组件更新状态 → 状态变化触发事件 → 集成层监听并同步到缓存 → 缓存持久化
```

### API → 状态 → UI流程

```
API请求数据 → 响应被缓存 → 数据更新状态 → 状态变化触发UI更新
```

### 离线数据流

```
检测到离线 → 读取缓存数据 → 显示缓存数据 → 操作进入离线队列 → 网络恢复后同步
```

## 错误处理与恢复

系统采用多级错误处理策略：

1. **React组件级**：使用ErrorBoundary捕获渲染错误
2. **API请求级**：请求失败时自动重试或使用缓存数据
3. **全局级**：捕获未处理的异常并通过事件总线统一处理
4. **UI反馈**：向用户提供友好的错误信息和恢复选项

## 使用示例

### 初始化应用

```typescript
// 在应用入口点调用
import { initializeApp } from '@/core/init';

initializeApp({
  debug: process.env.NODE_ENV === 'development',
  enableAutoRefresh: true,
});
```

### 使用统一缓存API

```typescript
import { unifiedCache } from '@/core/integration';

// 设置缓存
unifiedCache.set('user:preferences', preferences, {
  ttl: 30 * 24 * 60 * 60 * 1000, // 30天
  tags: ['user', 'preferences']
});

// 获取缓存
const preferences = unifiedCache.get('user:preferences');

// 按标签清理缓存
unifiedCache.removeByTag('user');
```

### 状态与缓存协作

```typescript
import { useStore } from '@/core/store';
import { unifiedCache } from '@/core/integration';

// 在组件中
function SaveUserPreferences(preferences) {
  // 更新状态 - 会自动同步到缓存
  useStore.getState().updatePreferences(preferences);
  
  // 也可以手动管理缓存
  unifiedCache.saveState('user', { preferences });
}
```

## 性能考量

- 缓存项自动过期，避免存储空间无限增长
- 使用LRU策略在缓存满时淘汰最少使用的项
- 按需加载机制，减少初始加载时间
- 定期清理过期缓存，保持高效性能

## 后续扩展计划

1. 添加IndexedDB存储适配器，支持大型数据集缓存
2. 实现离线数据冲突检测与解决策略
3. 增强数据同步和版本控制能力
4. 添加缓存压缩和加密选项 